<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mystický rybník</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: radial-gradient(circle at center, #020202 0%, #000 100%);
      overflow: hidden;
    }
    .container {
      position: relative;
      width: 600px;
      height: 600px;
    }
    canvas {
      border-radius: 50%;
      box-shadow: 0 0 100px rgba(0, 255, 180, 0.2),
                  inset 0 0 80px rgba(0, 120, 90, 0.3);
    }
  </style>
</head>
<body>
  <div class="container">
    <canvas id="canvas"></canvas>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 600;
    canvas.height = 600;

    let time = 0;

    // --- Ripple Generator ---
    class WaveGenerator {
      constructor() {
        this.nodes = [];
        for (let i = 0; i < 30; i++) {
          this.nodes.push({
            x: Math.random() * 600,
            y: Math.random() * 600,
            phase: Math.random() * Math.PI * 2,
            speed: 0.3 + Math.random() * 1.2,
            radius: 20 + Math.random() * 60
          });
        }
      }
      getValue(x, y, t) {
        let sum = 0;
        for (let node of this.nodes) {
          const dx = x - node.x;
          const dy = y - node.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          sum += Math.sin(dist * 0.03 + t * node.speed + node.phase) * (node.radius / dist);
        }
        return sum;
      }
    }
    const waveGen = new WaveGenerator();

    function drawWaterSurface(t) {
      const centerX = 300, centerY = 300;
      const speedMult = 2.5;

      // Base water gradient
      const baseGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 300);
      baseGradient.addColorStop(0, '#1b2b20');
      baseGradient.addColorStop(0.4, '#101710');
      baseGradient.addColorStop(1, '#060906');
      ctx.fillStyle = baseGradient;
      ctx.fillRect(0, 0, 600, 600);

      // Ripples (pixel manipulation)
      const imageData = ctx.getImageData(0, 0, 600, 600);
      const data = imageData.data;
      for (let y = 0; y < 600; y += 4) {
        for (let x = 0; x < 600; x += 4) {
          const waveValue = waveGen.getValue(x, y, t * speedMult);
          const normalized = (Math.sin(waveValue) + 1) * 0.5;
          const idx = (y * 600 + x) * 4;

          if (normalized > 0.6) { // highlights
            data[idx] = 80 + normalized * 100;
            data[idx + 1] = 140 + normalized * 90;
            data[idx + 2] = 110 + normalized * 70;
          } else if (normalized > 0.4) { // mid-tones
            data[idx] = 40 + normalized * 70;
            data[idx + 1] = 90 + normalized * 90;
            data[idx + 2] = 60 + normalized * 80;
          } else { // shadows
            data[idx] = 10 + normalized * 30;
            data[idx + 1] = 20 + normalized * 40;
            data[idx + 2] = 15 + normalized * 25;
          }
        }
      }
      ctx.putImageData(imageData, 0, 0);

      // Caustics glow
      ctx.globalCompositeOperation = 'screen';
      ctx.globalAlpha = 0.2;
      for (let i = 0; i < 30; i++) {
        const angle = (i / 30) * Math.PI * 2 + t * 0.15;
        const radius = 120 + Math.sin(t + i) * 80;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;
        const size = 60 + Math.sin(t * 0.7 + i) * 30;
        const grd = ctx.createRadialGradient(x, y, 0, x, y, size);
        grd.addColorStop(0, 'rgba(100, 255, 200, 0.5)');
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd;
        ctx.fillRect(x - size, y - size, size * 2, size * 2);
      }

      // Floating runes
      ctx.globalAlpha = 0.7;
      ctx.strokeStyle = `rgba(0, 255, 200, 0.5)`;
      ctx.lineWidth = 1;
      for (let i = 0; i < 6; i++) {
        const r = 80 + i * 35 + Math.sin(t * 0.8 + i) * 10;
        ctx.beginPath();
        for (let a = 0; a <= Math.PI * 2; a += 0.3) {
          const x = centerX + Math.cos(a + t * 0.3) * r;
          const y = centerY + Math.sin(a + t * 0.3) * r;
          ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
      }

      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = 'source-over';
    }

    function animate() {
      time += 0.04;
      drawWaterSurface(time);
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>
